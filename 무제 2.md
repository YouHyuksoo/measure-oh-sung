좋아요! 아래는 **전력(W) + 전압(V) + 전류(A) + 주파수(Hz)** 를 지원하는 **RS-232 에뮬레이터(ASCII 프로토콜)**의 **단일 파일 파이썬 코드**입니다.

- 기본 통신: **115200-8-N-1, 흐름제어 없음, LF(\n)로 줄 종료**
    
- 케이블: **Null-modem(교차, DB-9: 2↔3, 3↔2, 5↔5)**
    
- 연결 확인: `*IDN?` 질의 시 장비 정보 문자열 회신
    

이 설정과 절차는 제공해주신 GPT-9000 시리즈 설명서의 RS-232 구성(보드레이트/프레이밍/Null-modem)과 원격 연결 확인(`*idn?`) 안내를 근거로 했습니다.

---

## 파이썬 코드 (Python 3, `pyserial` 필요)

> 설치: `pip install pyserial`

```python
# rs232_power_vif_emulator.py
# RS-232 ASCII 프로토콜: *IDN?, *RST, SYST:ERR?, STAT?, INIT, ABORT
# 측정 질의: MEAS:POW? / MEAS:VOLT? / MEAS:CURR? / MEAS:FREQ? / READ?
# 설정: CONF:RATE <ms>, CONF:PF <0..1>, CONF:V:BASE <V>, CONF:I:BASE <A>, CONF:FREQ:BASE <Hz>
#      CONF:V:RANGE <Vmax>, CONF:I:RANGE <Amax>, CONF:NOISE V,<%>; I,<%>; F,<%>, CONF:STREAM ON|OFF
# 라인 종료: LF('\n'), 인코딩: UTF-8
import sys, time, threading, random, re, math
try:
    import serial
except ImportError:
    print("pip install pyserial 를 먼저 설치하세요.")
    sys.exit(1)

LF = "\n"
OK = "OK"
BANNER = "PWR-EMU,MODEL-PE200,FW1.1.0,SN000001"

ERR_SYNTAX = 'ERR,-100,"Syntax error"'
ERR_RANGE  = 'ERR,-200,"Parameter out of range"'
ERR_EXEC   = 'ERR,-300,"Execution error"'
ERR_BUSY   = 'ERR,-350,"Operation in progress"'
ERR_DEV    = 'ERR,-500,"Device error"'

STATE_READY = "READY"
STATE_RUN   = "RUN"
STATE_HOLD  = "HOLD"
STATE_ERROR = "ERROR"

def clip(x, lo, hi):
    return max(lo, min(hi, x))

class VIFPowerModel:
    """전압/전류/주파수 샘플을 생성하고 P = V * I * PF 계산"""
    def __init__(self):
        # 기준값(사용자 설정으로 변경 가능)
        self.V0 = 220.0     # volts
        self.I0 = 0.600     # amps
        self.F0 = 60.00     # Hz
        self.PF = 1.000
        # 노이즈(% 표준편차)
        self.noise_v = 0.5    # %
        self.noise_i = 1.0    # %
        self.noise_f = 0.05   # %
        # 레인지(최대값)
        self.v_range = 600.0
        self.i_range = 10.0
        # 내부 상태
        self.ts = time.time()
        self.lastV = self.V0
        self.lastI = self.I0
        self.lastF = self.F0
        self.lastP = self.V0 * self.I0 * self.PF
        self.energy_Wh = 0.0

    def set_base(self, kind, val):
        if kind == "V":
            if not (0 <= val <= 1000): return False
            self.V0 = val
        elif kind == "I":
            if not (0 <= val <= 100): return False
            self.I0 = val
        elif kind == "F":
            if not (0 <= val <= 1000): return False
            self.F0 = val
        return True

    def set_range(self, kind, val):
        if kind == "V":
            if val not in (150, 300, 600, 1000): return False
            self.v_range = float(val)
        elif kind == "I":
            if val not in (1, 5, 10, 20, 100): return False
            self.i_range = float(val)
        return True

    def set_noise(self, v=None, i=None, f=None):
        if v is not None:
            if not (0 <= v <= 20): return False
            self.noise_v = float(v)
        if i is not None:
            if not (0 <= i <= 50): return False
            self.noise_i = float(i)
        if f is not None:
            if not (0 <= f <= 10): return False
            self.noise_f = float(f)
        return True

    def set_pf(self, pf):
        if not (0.0 <= pf <= 1.0): return False
        self.PF = float(pf)
        return True

    def zero_energy(self):
        self.energy_Wh = 0.0

    def next_sample(self, dt_s):
        # 가우시안 노이즈 적용 (표준편차 = 기준값 * %/100)
        V = clip(random.gauss(self.V0, self.V0 * self.noise_v / 100.0), 0.0, self.v_range)
        I = clip(random.gauss(self.I0, self.I0 * self.noise_i / 100.0), 0.0, self.i_range)
        F = clip(random.gauss(self.F0, self.F0 * self.noise_f / 100.0), 0.0, 1000.0)
        P = max(0.0, V * I * self.PF)
        self.lastV, self.lastI, self.lastF, self.lastP = V, I, F, P
        # 에너지 적산 (Wh)
        self.energy_Wh += (P * dt_s) / 3600.0
        self.ts = time.time()

    def snapshot(self):
        return dict(ts=self.ts, V=self.lastV, I=self.lastI, F=self.lastF, P=self.lastP, ENER=self.energy_Wh)

class RS232VIFPowerEmu:
    def __init__(self, port, baud=115200):
        self.port_name = port
        self.baud = baud
        self.ser = serial.Serial(
            port=port, baudrate=baud,
            bytesize=serial.EIGHTBITS, parity=serial.PARITY_NONE, stopbits=serial.STOPBITS_ONE,
            timeout=0.1, xonxoff=False, rtscts=False, dsrdtr=False
        )
        self.model = VIFPowerModel()
        self.rate_ms = 100
        self.state = STATE_READY
        self.stream_on = False
        self.running = True
        self.lock = threading.Lock()
        self.err_stack = []  # 간단한 에러 스택

    # ---- 직렬 헬퍼
    def _writeline(self, s):
        try:
            self.ser.write((s + LF).encode("utf-8"))
        except Exception:
            pass

    def _push_err(self, code_msg):
        self.err_stack.append(code_msg)

    # ---- 샘플러/스트리머 스레드
    def sampler(self):
        last = time.time()
        while self.running:
            time.sleep(self.rate_ms / 1000.0)
            now = time.time()
            dt = max(0.0, now - last)
            last = now
            with self.lock:
                if self.state == STATE_RUN:
                    self.model.next_sample(dt)
                    if self.stream_on:
                        s = self.model.snapshot()
                        line = f"{s['ts']:.3f}, {s['P']:.3f}, {s['V']:.2f}, {s['I']:.3f}, {s['F']:.2f}, {self.state}"
                        # 헤더는 최초 ON 시점에 컨트롤 플레인에서 한 번만 보낸다. (간단화)
                        self._writeline(line)

    # ---- 명령 처리
    def handle_line(self, raw):
        s = raw.strip()
        if not s:
            return
        u = s.upper()

        try:
            # 식별/상태/에러
            if u == "*IDN?":
                self._writeline(BANNER)
            elif u == "*RST":
                with self.lock:
                    self.__init_state_reset()
                self._writeline(OK)
            elif u == "SYST:ERR?":
                if self.err_stack:
                    self._writeline(self.err_stack.pop(0))
                else:
                    self._writeline('0,"No error"')
            elif u == "STAT?":
                self._writeline(self.state)

            # 제어
            elif u == "INIT":
                with self.lock:
                    self.state = STATE_RUN
                self._writeline(OK)
            elif u == "ABORT":
                with self.lock:
                    self.state = STATE_READY
                self._writeline(OK)

            # 측정 질의
            elif u == "MEAS:POW?":
                with self.lock:
                    p = self.model.lastP
                self._writeline(f"{p:.3f}W")
            elif u == "MEAS:VOLT?":
                with self.lock:
                    v = self.model.lastV
                self._writeline(f"{v:.2f}V")
            elif u == "MEAS:CURR?":
                with self.lock:
                    i = self.model.lastI
                self._writeline(f"{i:.3f}A")
            elif u == "MEAS:FREQ?":
                with self.lock:
                    f = self.model.lastF
                self._writeline(f"{f:.2f}Hz")
            elif u == "MEAS:ENER?":
                with self.lock:
                    e = self.model.energy_Wh
                self._writeline(f"{e:.6f}Wh")
            elif u == "READ?":
                with self.lock:
                    snap = self.model.snapshot()
                    st = self.state
                self._writeline(
                    "RES,POW={:.3f}W,V={:.2f}V,I={:.3f}A,FREQ={:.2f}Hz,ENER={:.6f}Wh,STAT={}".format(
                        snap["P"], snap["V"], snap["I"], snap["F"], snap["ENER"], st
                    )
                )

            # 설정
            elif u.startswith("CONF:RATE"):
                m = re.match(r"(?i)^CONF:RATE\s+(\d+)\s*ms$", s)
                if not m: return self._writeline(ERR_SYNTAX)
                val = int(m.group(1))
                if 20 <= val <= 10000:
                    with self.lock: self.rate_ms = val
                    self._writeline(OK)
                else:
                    self._writeline(ERR_RANGE)

            elif u.startswith("CONF:PF"):
                m = re.match(r"(?i)^CONF:PF\s+([0-1](?:\.\d+)?)$", s)
                if not m: return self._writeline(ERR_SYNTAX)
                pf = float(m.group(1))
                with self.lock:
                    if self.model.set_pf(pf): self._writeline(OK)
                    else: self._writeline(ERR_RANGE)

            elif u.startswith("CONF:V:BASE"):
                m = re.match(r"(?i)^CONF:V:BASE\s+([0-9]+(?:\.[0-9]+)?)V$", s)
                if not m: return self._writeline(ERR_SYNTAX)
                val = float(m.group(1))
                with self.lock:
                    if self.model.set_base("V", val): self._writeline(OK)
                    else: self._writeline(ERR_RANGE)

            elif u.startswith("CONF:I:BASE"):
                m = re.match(r"(?i)^CONF:I:BASE\s+([0-9]+(?:\.[0-9]+)?)A$", s)
                if not m: return self._writeline(ERR_SYNTAX)
                val = float(m.group(1))
                with self.lock:
                    if self.model.set_base("I", val): self._writeline(OK)
                    else: self._writeline(ERR_RANGE)

            elif u.startswith("CONF:FREQ:BASE"):
                m = re.match(r"(?i)^CONF:FREQ:BASE\s+([0-9]+(?:\.[0-9]+)?)Hz$", s)
                if not m: return self._writeline(ERR_SYNTAX)
                val = float(m.group(1))
                with self.lock:
                    if self.model.set_base("F", val): self._writeline(OK)
                    else: self._writeline(ERR_RANGE)

            elif u.startswith("CONF:V:RANGE"):
                m = re.match(r"(?i)^CONF:V:RANGE\s+(150|300|600|1000)V$", s)
                if not m: return self._writeline(ERR_SYNTAX)
                rng = int(m.group(1))
                with self.lock:
                    if self.model.set_range("V", rng): self._writeline(OK)
                    else: self._writeline(ERR_RANGE)

            elif u.startswith("CONF:I:RANGE"):
                m = re.match(r"(?i)^CONF:I:RANGE\s+(1|5|10|20|100)A$", s)
                if not m: return self._writeline(ERR_SYNTAX)
                rng = int(m.group(1))
                with self.lock:
                    if self.model.set_range("I", rng): self._writeline(OK)
                    else: self._writeline(ERR_RANGE)

            elif u.startswith("CONF:NOISE"):
                # 예: CONF:NOISE V,0.5; I,1.0; F,0.05
                try:
                    v = i = f = None
                    # 토크나이즈
                    body = s.split(None, 1)[1]
                    parts = [p.strip() for p in body.split(";")]
                    for p in parts:
                        if not p: continue
                        k, val = [x.strip() for x in p.split(",", 1)]
                        if k.upper() == "V": v = float(val)
                        elif k.upper() == "I": i = float(val)
                        elif k.upper() == "F": f = float(val)
                    with self.lock:
                        if self.model.set_noise(v, i, f): self._writeline(OK)
                        else: self._writeline(ERR_RANGE)
                except Exception:
                    self._writeline(ERR_SYNTAX)

            elif u == "CONF:ENER:ZERO":
                with self.lock:
                    self.model.zero_energy()
                self._writeline(OK)

            elif u.startswith("CONF:STREAM"):
                m = re.match(r"(?i)^CONF:STREAM\s+(ON|OFF)$", s)
                if not m: return self._writeline(ERR_SYNTAX)
                onoff = m.group(1).upper()
                with self.lock:
                    self.stream_on = (onoff == "ON")
                if self.stream_on:
                    # 헤더 1회 전송
                    self._writeline("ts, pow_w, volt_v, curr_a, freq_hz, stat")
                self._writeline(OK)

            else:
                self._writeline(ERR_SYNTAX)

        except Exception:
            self._push_err(ERR_DEV)
            self._writeline(ERR_DEV)

    def __init_state_reset(self):
        # *RST 기본값 설정
        self.model = VIFPowerModel()
        self.rate_ms = 100
        self.state = STATE_READY
        self.stream_on = False
        self.err_stack.clear()

    def serve(self):
        sampler_thread = threading.Thread(target=self.sampler, daemon=True)
        sampler_thread.start()

        buf = bytearray()
        try:
            while self.running:
                data = self.ser.read(1024)
                if not data:
                    continue
                buf.extend(data)
                while b"\n" in buf:
                    line, _, buf = buf.partition(b"\n")
                    try:
                        self.handle_line(line.decode("utf-8", "ignore"))
                    except Exception:
                        self._push_err(ERR_DEV)
                        self._writeline(ERR_DEV)
        finally:
            self.close()

    def close(self):
        self.running = False
        try:
            if self.ser and self.ser.is_open:
                self.ser.close()
        except Exception:
            pass

def main():
    if len(sys.argv) < 2:
        print("사용법: python rs232_power_vif_emulator.py <COM포트> [baud]")
        print("예시 : python rs232_power_vif_emulator.py COM9 115200")
        return
    port = sys.argv[1]
    baud = int(sys.argv[2]) if len(sys.argv) >= 3 else 115200
    emu = RS232VIFPowerEmu(port, baud)
    print(f"RS-232 VIF Power Emulator: {port} @ {baud} (LF 종료, 8-N-1, flowcontrol None)")
    try:
        emu.serve()
    except KeyboardInterrupt:
        pass
    finally:
        emu.close()

if __name__ == "__main__":
    main()
```

---

## 사용 방법 (예: Windows, 가상 Null-modem 쌍)

1. **가상 COM 포트 페어**(예: `COM1 ↔ COM2`) 생성 — Null-modem(교차)
    
    - 실제 배선은 DB-9 **2(RxD)/3(TxD)/5(GND)** 이 교차 연결입니다.
        
2. **에뮬레이터 실행**
    
    ```bash
    python rs232_power_vif_emulator.py COM9 115200
    ```
    
3. **터미널/테스트 프로그램**에서 `COM10`, **115200-8-N-1, 흐름제어 없음**, 줄바꿈 **LF(\n)** 로 열기.
    
4. **연결 확인 및 질의** (한 줄씩 전송)
    
    ```
    *IDN?
    *RST
    STAT?
    CONF:V:BASE 230.0V
    CONF:I:BASE 0.500A
    CONF:FREQ:BASE 60.00Hz
    CONF:PF 0.95
    CONF:RATE 100ms
    INIT
    READ?
    MEAS:POW?
    MEAS:VOLT?
    MEAS:CURR?
    MEAS:FREQ?
    CONF:STREAM ON
    # 스트리밍 라인과 OK가 순차 출력됨
    CONF:STREAM OFF
    ABORT
    SYST:ERR?
    ```
    
    - `*IDN?` 에 모델/시리얼/펌웨어 응답이 오면 RS-232 링크 정상입니다.
        

---

## 프로토콜 요약

- **요청**: `*IDN?`, `*RST`, `SYST:ERR?`, `STAT?`, `INIT`, `ABORT`
    
- **측정 질의**: `MEAS:POW?`, `MEAS:VOLT?`, `MEAS:CURR?`, `MEAS:FREQ?`, `MEAS:ENER?`, `READ?`
    
- **설정**: `CONF:RATE <ms>`, `CONF:PF <0..1>`, `CONF:V:BASE <V>`, `CONF:I:BASE <A>`,  
    `CONF:FREQ:BASE <Hz>`, `CONF:V:RANGE <150|300|600|1000>V`, `CONF:I:RANGE <1|5|10|20|100>A`,  
    `CONF:NOISE V,<%>; I,<%>; F,<%>`, `CONF:ENER:ZERO`, `CONF:STREAM ON|OFF`
    
- **응답**: 성공=`OK`, 실패=`ERR,<code>,"<message>"`
    
- **라인 종료**: **LF(\n)**, 인코딩 **UTF-8**
    

---

## 근거(출처)

- **RS-232 구성**: 보드레이트 `9600/19200/38400/57600/115200`, 패리티 없음, 데이터 8, 스톱 1, **흐름제어 없음**.
    
- **DB-9 핀아웃/Null-modem 교차**: 2=RxD, 3=TxD, 5=GND / PC 2↔장비 3, 3↔2, 5↔5.
    
- **원격 연결 확인**: `*idn?` 전송 시 모델/시리얼/펌웨어 문자열 회신 예시.
    

---

필요하면 **CSV 스트리밍 헤더/포맷 변경**, **PF=0~1 이외 위상각 기반(P=VIcosφ)**, **에너지 적산 리셋 타이밍**, **상태머신 디테일** 등도 맞춤 수정해 드릴게요.