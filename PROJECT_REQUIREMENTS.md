# 프로젝트 요구사항 정의서 (PRD)

## 1. 프로젝트 개요

### 1.1. 목표

계측 장비 제어 및 데이터 수집을 위한 웹 기반 애플리케이션을 개발한다. 이 애플리케이션은 실시간 바코드 트리거 검사 루틴 및 유연한 설정 관리 기능을 제공한다.
사용자는 계측기로부터 받은 데이터를 시각화 하고 조건에 따라 판정을 하고 DB 에 저장한다.

기존에 이미구현된 소스를 최대한 참조한다.
참조할 폴더는 D:\Project\measure-ohsung

### 1.2. 시스템 개요

- **백엔드:** Python (FastAPI) 기반의 REST API 및 WebSocket 서버.
- **프론트엔드:** Next.js (React) 기반의 웹 UI (shadcn/ui, Tailwind CSS).
- **핵심 기능:** 바코드 스캔으로 트리거되는 3단계 계측 루틴, 유연한 검사 설정 및 모델별 상/하한값 관리.

## 2. 핵심 기능 요구사항

### 2.1. 검사 루틴 (Inspection Routine)

- **트리거:** 단일 바코드 스캔으로 전체 검사 루틴 시작.
- **단계:** 총 3단계의 측정 부위(P1, P2, P3)에 대한 순차적 검사.
- **흐름:**
  1.  바코드 스캔.
  2.  P1 측정 시작: 설정된 시간(X초) 동안 계측기로부터 **전압(또는 전류) 값을 실시간으로 받아와** 수집. 수집된 값들은 검사 모델의 P1 상/하한 스펙과 비교하여 해당 단계의 합불 여부를 실시간으로 판단.
  3.  P1-P2 대기: 설정된 시간(Y초) 동안 대기.
  4.  P2 측정 시작: 설정된 시간(X초) 동안 계측기로부터 **전압(또는 전류) 값을 실시간으로 받아와** 수집. 수집된 값들은 검사 모델의 P2 상/하한 스펙과 비교하여 해당 단계의 합불 여부를 실시간으로 판단.
  5.  P2-P3 대기: 설정된 시간(Z초) 동안 대기.
  6.  P3 측정 시작: 설정된 시간(X초) 동안 계측기로부터 **전압(또는 전류) 값을 실시간으로 받아와** 수집. 수집된 값들은 검사 모델의 P3 상/하한 스펙과 비교하여 해당 단계의 합불 여부를 실시간으로 판단.
  7.  종합 판정: 각 단계에서 실시간으로 수집된 전압(또는 전류) 값들이 검사 모델의 해당 단계별 상/하한 스펙을 모두 만족하는지 종합적으로 판단하여 최종 '합격' 또는 '불합격' 판정.
- **실시간 표시:** 백엔드는 **WebSocket**을 통해 프론트엔드로 실시간 계측 데이터를 푸시하고, 프론트엔드는 이를 활용하여 **실시간 차트 모니터링**을 제공한다.

### 2.2. 설정 관리 (Configuration Management)

- **2.2.1. 검사 시간 설정 (Test Sequence Settings)**
  - **UI:** 프론트엔드에 전용 설정 페이지 제공.
  - **항목:**
    - `p1_measure_duration` (P1 측정 시간)
    - `wait_duration_1_to_2` (P1-P2 대기 시간)
    - `p2_measure_duration` (P2 측정 시간)
    - `wait_duration_2_to_3` (P2-P3 대기 시간)
    - `p3_measure_duration` (P3 측정 시간)
  - **저장:** 백엔드 `TestSettings` 테이블에 저장 및 관리.
- **2.2.2. 검사 모델 관리 (Inspection Model Management)**
  - **UI:** 프론트엔드에 전용 CRUD(생성, 조회, 수정, 삭제) 페이지 제공.
  - **항목 (각 모델별):**
    - `model_name` (모델 이름)
    - `p1_lower_limit`, `p1_upper_limit` (P1 검사 상/하한값)
    - `p2_lower_limit`, `p2_upper_limit` (P2 검사 상/하한값)
    - `p3_lower_limit`, `p3_upper_limit` (P3 검사 상/하한값)
  - **저장:** 백엔드 `InspectionModel` 테이블에 저장 및 관리.

### 2.3. 장비 관리 (Device Management)

- **장비 연결 및 통신:** SCPI(Standard Commands for Programmable Instruments) 프로토콜을 기반으로 **RS-232 시리얼 통신**을 사용한다. 통신 파라미터는 **포트(COMx), 보드레이트(9600, 115200 등), 데이터 비트(8), 패리티(None), 스톱 비트(1), 흐름 제어(None), 타임아웃** 등을 설정할 수 있다. 각 장비의 IDN 응답을 파싱하여 제조사, 모델명, 펌웨어 버전 등을 식별하고, 장비별 특성(예: 응답 형식, 명령어 지연 시간)을 고려한 통신 처리가 필요하다.
- **장비 등록 및 관리:** 수동으로 장비 연결 정보를 등록, 수정, 삭제.
- **Python 로직 활용:** `src/communication`, `src/devices` 등 기존 Python 로직을 백엔드에서 활용하여 장비 제어.

### 2.4. 데이터 관리 (Data Management)

- **측정 데이터 저장:** SQLite 데이터베이스의 `Measurement` 테이블에 모든 측정 결과 저장.
- **과거 데이터 조회 및 분석:** 저장된 과거 측정 데이터를 필터링하여 조회하고, 간단한 분석 기능 제공 (UI 필요).
- **시스템 로그 저장:** 애플리케이션 시스템 로그를 데이터베이스에 저장 및 관리 (UI 필요).

### 2.5. 명령어 관리 (Command Management)

- **SCPI 명령어 라이브러리:** 장비별 SCPI 명령어 목록을 관리 (UI 필요).

## 3. 기술 스택

### 3.1. 백엔드

- **언어:** Python
- **프레임워크:** FastAPI (비동기 처리 및 내장 WebSocket 지원을 통해 실시간 통신에 최적화)
- **데이터베이스:** SQLite (기존 `measurements.db` 사용, 신규 테이블 추가)
- **의존성:** `uvicorn`, `sqlalchemy`, `python-multipart`, `alembic` 등

### 3.2. 프론트엔드

- **프레임워크:** Next.js (App Router, TypeScript)
- **UI 라이브러리:** shadcn/ui (Tailwind CSS 기반의 재사용 가능하고 접근성 높은 컴포넌트 라이브러리 활용)
- **CSS 프레임워크:** Tailwind CSS
- **실시간 차트:** 수신된 WebSocket 데이터를 기반으로 실시간으로 업데이트되는 차트 구현.
- **포트:** 개발 서버 기본 포트 3001 (또는 가변적)

화면 구성은 상단에 헤더 , 사이드 메뉴 ( 접고 펼수 있어야 함 ) , 중앙패널로 구성하고
데이터을 설비롤 부터 통신으로 받아와서 판정을 하는 주 기능은 전체 화면으로 구성
화면은 3개의 패널로 구성해 서 검사 단계 3 개와 각각 대응되는 구조로 ,
패널마다 상단은 수집된 데이터 , 하단은 수집된 데이타로 시각화 선 으로 차트표시 로 3 개를 동일한 형태로 구성 해야한다.

## 4. 제외된 기능

- 장비 자동 스캔 기능.
- 장비 에뮬레이터 (데모 모드) 기능.
- 별도의 '바코드 기반 측정 세션' 시작/종료 버튼 (바코드 스캔이 전체 루틴의 트리거 역할로 통합).

## 5. 기타 고려사항

- **Node.js 버전:** Node.js 20.x LTS 버전 권장 (현재 Node.js 22.x 버전에서 `lightningcss` 등 일부 모듈 호환성 문제 발생).
- **CORS:** 백엔드(FastAPI)에서 프론트엔드(Next.js)의 요청을 허용하도록 CORS 설정 필요.
- **에러 처리:** 각 단계별 견고한 에러 처리 및 사용자에게 피드백 제공.
- **성능:** 백엔드의 효율적인 데이터 처리 및 프론트엔드의 실시간 차트 렌더링 성능 최적화는 사용자 경험에 매우 중요.
- **장비 특성 반영:** 각 계측 장비의 고유한 통신 프로토콜, 데이터 형식, 응답 특성 등을 백엔드 로직에 반영하여 안정적인 통신과 정확한 데이터 파싱을 보장해야 한다.
- **통신 오류 처리:** 장비 연결 끊김, 타임아웃, 잘못된 응답 등 통신 과정에서 발생할 수 있는 다양한 오류 상황에 대한 견고한 처리 로직이 필요하다.
